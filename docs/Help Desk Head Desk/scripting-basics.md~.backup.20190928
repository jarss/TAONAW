+++
title = "the weekly template script"
author = ["Josh Rollins"]
publishDate = 2019-09-03T00:00:00-04:00
lastmod = 2019-09-08T08:51:52-04:00
draft = false
+++

## Introduction {#introduction}

I alway say I'm a non-programmer, non-scripter computer geek. As such, I somehow I ended up with several useful scripts on my Linux machine. I'm not sure how this happened besides the fact that I've always been curious and looking for a way to improve things.

Two things I want to say about this easily longest post I've written, before we dive in:

If you're a seasoned programmer or an exeprieced Linux user, you might laugh at my code and have quite a few harsh remarks. Good. Maybe that will get you to point these problems out to me so I improve even further.

If you're new to Linux and scripting and looking for a place to start -- this is probably not it. There's a good chance this post will confuse you more than it will help. But, I do hope it will get you close enough to start looking for solutions on your own, ask questions, and most importantly, teach you that being afraid of something new doesn't mean you have to not do anything about it.


### The Basic Requierments {#the-basic-requierments}

Those in the second group, there are a few things I need to bring you up to speed about:

1.  A script is nothing more than a text file containing various commands in BASH (Linux's deafult shell). You can use any text editor you'd like, it doesn't matter.

2.  Speaking of a text editor, if you're on Linux, you probably have Nano built in (type "nano" in terminal to bring it up), but it has a slight learning curve with its weird key bindings. [Here's a quick guide](https://www.lifewire.com/beginners-guide-to-nano-editor-3859002) to get you started with it.

3.  In Linux, it doesn't matter what extension your file has. That world belong to Windows and somewhat to MacOs. You can save it as  "myfirstscript" and it will run just fine without an extension.[^fn:1]

4.  What _is_ important in Linux is permissions, which is a whole topic in itself. In order to allow a text file to run as an executible chain of commands, you need to give it permsission to do so. When done with the script, type in your terminal "chmod +x [your script path and name here]"[^fn:2] to tell Linux this is an executible file.

5.  You can't just run the script by typing it out in command line. That's because it's not part of your system's path configuration, which tells Linux where are the scripts and programs you can run are.[^fn:3] You have to be specific and write out the entire path "[path/to/your/script/script here]" or be in the same directory as the script and execute it with `./[script here]`.

Hopefully the above make some sense. Let's continue and talk about our script:

```nil
#!/bin/bash

filename=w`date +%V_%y`
init_mon=`date +%Y-%m-%d`

cp /media/pispace/Documents/Archive/weekly-template.org /media/pispace/Documents/Archive/$filename.org

#+TITLE: Week Starting Monday 2019-02-11
sed -i "1s/^/#+TITLE: Week Starting Monday $init_mon\n/" /media/pispace/Documents/Archive/$filename.org
```

What does it do?

A practical little thing, this script creates a new .org file for me every week[^fn:4] from a template, and changes its title to "Week Starting Monday [date]" where the date updated based on that week's date.

So for example, on 02-09-2019 (at 3:00 AM specifically), my Rraspberry Pi created a new org file. The first file in that line, which is the title, reads "Week Starting Monday 2019-09-02" (I like my dates backwards).

How does it do it?

Ah. Well, this is what this post is about. Let's dive in:


## The Shebang {#the-shebang}

The very first line, #!/bin/bash, is called shebang (or hashbang, but shebang seems to be more popular). Every script in shell starts with a shebang. But what is this cryptic line do? We're just on the first line and it already seems like we need to learn another language!

Everything is scary before you understand it, little grasshopers.

The "#" sign is usually used to enter a comment into your script. This means this line is not meant to be run as a command, and should be skipped. When combined with a "!" it creates a special combo[^fn:5] called the [interperter directive](https://en.wikipedia.org/wiki/Interpreter%5Fdirective), which tells our computer how to interpert the script we're about to write - or more percisly, where _is_ the interperter so the computer can find it and use it.

Since we're about to write a script in bash, we need to tell our computer: "OK, this file is written in bash, here's where you find bash" which is exactly what the next part is: `/bin/bash`.  this is where bash is, in your `/etc/bash` folder. If it was in a folder named giraf, for example, it would be `#!/giraf/bash`.


## Varibles {#varibles}

This is probably one of the most popular phrase dropped around when you hear someone talking abotu a script. A varible (or var for short) is a container for a piece of data, usually called a string (string is one type of data, but for our purposes here let's keep it simple)

Our script contains two varibles: filename and init-mon. It just makes sense if you look at it:

`filename=[something...]` and `init_mon=[something...]`. In bash, as soon as we place a "=" after a name like that, bash knows this is a variable. Simple. OK, so what exactly goes into these containers?  This seems complicated... Again, it's all about breaking things down.


## The Date Command, and Reading the Manual {#the-date-command-and-reading-the-manual}

This is our first real command here. If you copy `date +%V_%y` and run it in your terminal, you'd get a number, an underscore, and another number. If I type this today (which happens to be September 3, 2019), I'd get "36\_19". By the way, notice the plus sign before these options, it's important: in the manual it says to use plus when specifing a specific format to display.

We know a command named "date" is probably giving us date related output... and I just gave you today's date... can you guess what this command does? What are these numbers?

To be sure, let's run the _manual_ command on date. Type `man date` in your terminal. This is the manual for the date command (and yes, mostly every command in linux has a manual page, isn't this awesome?)

The most importat bits of info to get from the manual are the name, because it tells us what the command does right there: "print or set the system date and time", and then the description which is the same thing. Go ahead and run "date" without any formant options (that is, without the `%[something]`) part and see what it prints out by default; you'd notice it's the same as spcified under the "Synopsis" part of the manual.

In our case, we use the date command with specific formatting options. In the manual for the command, scroll down to "Format" to see these. Do you see how many options the date command has? You can print out the current century or seconds since the beginning of 1970[^fn:6]. The options used in the script, %V and %y, give out the week number in the year and the year's last two digits. The underscore in between is nothing but a seperator that will later show in the file name, to get the following format: [week number]\_[year two digits], which gets us something like "12\_19.org". Get it...?

The other variable, init\_mon, is another "twist" on the date command. Go ahead and try to figure out the options used on your own this time. Why do I need this second date? We will find out shortly.


## Copy Command and Using Variables {#copy-command-and-using-variables}

the next line starts with right away with a "cp". This is simply us writing out a command, nothing fancy. cp stands for copy  in linux, a command that copies files and directories. Don't take my word for it, check the manual! You know how now.

The command then says to copy my weekly org template (I talked about org files as templates [previously](https://joshrollinswrites.com/help-desk-head-desk/org-capture-in-files/)) from the origin directory to the destination directory (this format, of writing the origin location first, space, target location, is also noted in the manual. You have to follow this order), as a file named... "filename".org. And filename is the name of our variable, from earlier. We tell bash we want to use the data in a variable (remember, it's just a container) by writing a dollar sign in front of the name of the variable we want to use. I added ".org[^fn:7]" at the end because - you got it - this is going to be an .org file.


## The sed Command {#the-sed-command}

The Sed command, which stands for stream editor. This is one powerful command, which I'm only scartching the surface of. It allows you to manipulate text in all kinds of ways, but probably one of it's most popular usesages (as in this script) is to subtitute one line of text with another.

We call the command, sed, with option -i which tells it not to produce output. Basically "just do it, don't show me." This is because we don't want to see the replacement on the screen, we just want to manipulate a file.

The rest looks a bit crazy, but hang on, it makes sense:


### Using Quatation Marks {#using-quatation-marks}

We're going to use the quatation marks to include our entire stream (you can see it ends at the very end of the line). It's our way of telling sed to "take _this_" where this is everything included in quatation lines[^fn:8]. We need to use it here because our subtition includes spaces, and that usually interperts as a workflow instruction for the command: remember the cp command, and how it uses space to diffrintiate between the origin and the target? Well, something similar happens in sed, so if we just include spaces without the quatation marks, sed will not do what we want.


### Selecting the Right Text {#selecting-the-right-text}

Next, we have `1s/`. this is actually two in one combo: 1, for first line, and s, which tells sed we want a subtitution, thank you very much. Then we have a forward slash (remember, forward slash "/" because it leans forward; backward slash "\\" because it leans backwards) which is how we tell sed this is the expression we want to replace. In other words, we are selecting the text from here going forward, until the next forward slash.

Now wait a second, we already used the quatation marks for that, didn't we? Well yes. Kind of. The quatation marks acted as a wrapper for the whole expression, the text we want to replace (which is missing in this script, I will talk about this in a second), the text we want to replace with, varibles... the whole thing. Quatation marks work in bash in general is "wrappers" like this. The forward slash, on the other hand, is sepcific for the expressions _inside_ the command.

Think about it like a sandwhich: you order you sandwich, you get it wrapped in a wrap paper and a plastic bag. You don't eat those, that's just how you carry it home. Once you take it out, you still have a sandwich inside, and this sandwich includes the good stuff inside. The quataiton marks are the plastic bag and the wrap paper, the slashes represent the pieces of the bread. you eat those, they are part of the food command, the bag and paper are not. Both act as wrappers, but for different purposes.

The last part of selecting the text is the caret (`^`) sign. This is a regex expression (short for ["regular expression"](https://en.wikipedia.org/wiki/Regular%5Fexpression)) which says "this is the very first part of the line". Regex expressions are a whole world of their own, a powerful way to explain text strings to the computer. I explored [a bit of regex](https://joshrollinswrites.com/help-desk-head-desk/finding-non-macos14-compatible-macs/) on my own earlier, if you're interested - it's a good example to show when this comes in handy. Combined with the `1s` from earlier, it tells sed to select the first line, at the beginning. But if we're replacing a whole line, why do we can to tell sed to go to the very beginning? Ah ha! And you'd be right. The reason for that has to do with how this particular script is written.


### Replacing Text and placing in File {#replacing-text-and-placing-in-file}

Above, we went over how to direct sed to the right text we want it to replace, but we didn't tell it what to replace, and what to replace with. This is what's coming up next.

Remember how forward slashes represent the pieces of the sandwich for the sed command? These are called [delimiters](https://en.wikipedia.org/wiki/Delimiter). Sed subtitution defines our sandwich like so: "replace `/this/` with `/this/`" and it looks like "`/this/this/`". The first part tells sed what's getting replaced, the second part what it's replaced with.

In our script above, we told sed to replace the... nothing in the beginning of the line (there's nothing there after the `^` sign) with "`#+TITLE: Week Starting Monday $init_mon\n/`" because we specified nothing as what we want to replace, sed will simply replace the whole line. It won't search for anything specific. And to make sure it start right at the beginning of that line, we specifid the carot from before.

If you use org-mode like me, you'd recognize this bit of text: it's org-mode's syntax of specifing a title for an org file. So, our sed goes to the very beginning of the very first line and replaces the entire line there with the "#TITLE..." line.

You'd recall from before, where I discussed variables, what the dollar sign is: we're calling our `init-mon` variable here, which contains the full date every Monday: The title is "Week Starting Monday " and then the date as I explained above.

Finally, we have a special bit of regex again after we finished the replacing job (the forward slash after the variable): "`\n`". This means, "start a new line please," or in any word proccessing program, pressing the Enter key. Done, we just ate our sandwich, that's the end of the whole wrapper with quotation marks.

Then, we have space (it's a new line) which specifies the _target_ of the whole sed command. This is where I specify the file where this line of text should be added. In our case, the file we copied from our template above. So the sed command takes a generic line in the template that is served as a title holder (I simple typed in "#+TITLE: Week Starting Monday ----" but it could have said "pink rabbit" or simply nothing, doesn't matter, since this entire line is replaced) and replaces it with what we've done here.


### More about sed command {#more-about-sed-command}

I've used different sources when I wrote this post, and I'd just like to mention a few in case you're curious and want to go down the many holes of this awesome command.

First, there's the [GNU manul for this command](https://www.gnu.org/software/sed/manual/sed.pdf) which goes beyond the man page. Just so you get an idea, it's half a MB of a  PDF file with almost 40 pages. Yep, don't say I didn't warn you.

Then there's [this excellent tutorial](https://www.grymoire.com/Unix/Sed.html#TOC) that came up first in a search. It's long and thorough, with a touch of sense of humor. A bit more advanced.

If you want to read up more about regex, [I found this as a helpful reminder](https://www.rexegg.com/regex-quickstart.html).

And then you can always use stackoverflow for specific questions such as "[What does sed -i option do?](https://stackoverflow.com/questions/18527365/what-does-sed-i-option-do)"


## Conclusion {#conclusion}


## Footnotes {#footnotes}

[^fn:1]: - If you ever write scripts to execute in Mac or Windows (say, in another program) you'll notice these files has an ".sh" extension. But again, in Linux, this doesn't matter.
[^fn:2]: - chmod (change file mode) is a powerful and important command in Linux, outside of the scope of this post. You should check the manual for it (you should know how if you read through this post). This will take you down a rabbit whole regarding Linux file permissions, and you can [read more about it](https://devconnected.com/linux-file-permissions-complete-guide/) here (one of many links availble). Wikipedia [also has a good section](https://en.wikipedia.org/wiki/File%5Fsystem%5Fpermissions#Traditional%5FUnix%5Fpermissions) to get you started.
[^fn:3]: - The path in linux is a variable (you'll learn about those in a bit) which contains all the directories where your Linux knows to find scripts and commands. OK, but what does that mean? I can't get into it here (because I'll never get to publish this post) but enough to say that the script you're writing is not a "Liunx default" command, so Linux doesn't know it's a command. You have to point at it. This is somewhat of a problemetic explination, and I can't find a good place that explains what it _is_ (most places explains how to work with it), so I might expand on it myself.
[^fn:4]: - Automating tasks in Linux is done by a different component, called Cron. It takes a specific set of instructions written out in a string and translates it to a specific time loop (for me when using this script, on monday, 3AM, every week).
[^fn:5]: - This special combo is called a "magic number", it creates a unique value in ASCII that the comuter understands as a direct command. I am not sure how many magic numbers like these exist, this is an interesting path to head to.
[^fn:6]: - Another interesting segue here. Turns out that this date (1/1/1970) is know as "The Unix [Epoch](https://en.wikipedia.org/wiki/Epoch%5F(computing))." A quick search led me to this [this discussion](https://stackoverflow.com/questions/2533563/why-are-dates-calculated-from-january-1st-1970). Turns out such dates are common in the computing world.
[^fn:7]: - When scripting, certain special characters (like our $ above) are reserved. This means that if we wanted to call our variable "$usd" for example, we couldn't. There are certain ways to tell bash we want to use the character as a character, not as a "special signal." As a matter of fact, the dot in my .org is a bit dangerous because period also has a special meaning, though not in this case. I should have typed out something more specific telling bash the period here is meant as just a period, not a signal -- but at this point I'm not sure how the syntax would look like. I'm learning these things myself!
[^fn:8]: - Those of you who look carefully might find youself asking, "OK, but the qoutation marks _include_ the command syntax, not just the text we want to use, what's up with that? Why isn't it `1s/^/"#+TITLE: Week Starting`...? And I have a good answer: I don't know. It doesn't make sense to me either at the moment, but in all documentation I find, this is how the syntax works.