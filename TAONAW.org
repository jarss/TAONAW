#+TITLE: TAONAW Hugo Version
#+OPTIONS: num:nil toc:nil \n:nil
#+TODO: TODO(t) CANCELLED(c) |  ACTIVE(a) PUBLISHED(p)
#+hugo_base_dir: .
#+hugo_auto_set_lastmod: %Y-%m-%d


* Content
:PROPERTIES:
:EXPORT_HUGO_SECTION:
:END:

** About
  :PROPERTIES:
  :EXPORT_HUGO_SECTION: About
  :END:

*** TODO About JR
  :PROPERTIES:
  :EXPORT_HUGO_SECTION: About
  :EXPORT_FILE_NAME: about
  :END:

This is about JR

** Blog
  :PROPERTIES:
  :EXPORT_HUGO_SECTION: Blog
  :END:

*** PUBLISHED Hugo - what takes so long?
  :PROPERTIES:
  :EXPORT_HUGO_SECTION: Blog
  :EXPORT_FILE_NAME: Hugo: Beginnings
  :EXPORT_HUGO_PUBLISHDATE: 2018-10-04:
  :END:

 If you've been following me online for the last month or so (especially on reddit) you'd know I've been engaged in shifting away from WordPress and into the world [[https://gohugo.io/][Hugo]]. 

#+hugo: more 

 I'd imagine the people of in [[https://www.reddit.com/r/emacs/][r/emacs]] would raise an eyebrow at the term "world of Hugo." After all, Hugo is a relatively simple program, not a deep rabbit-hole like Emacs. Yet, it's Hugo that got me overwhelemed, not so much Emacs. What? Really? 

 You see, it has to do with background and expectations. As a non-programmer (as in, someone who never wrote anything a bit more complicated then a few lines of shell script) Emacs was a mountain. Standing at the bottom, I gazed at the cloud shrowing its peek and told myself "well, you gotta take a first step somewhere..." so I did. For me, that was Org-mode. As a matter of fact, at the time, I didn't even know much about Emacs and how deep it can get. All I knew was that Org was cool, and I'm interested in learning more.

 After a couple of months, I got a bit more comfortable with Emacs and my level of doing things with it. I am still miles away from the top, and I'm fine with that. I got Emacs to do most of what I want it to do for me at this point, which is writing these posts, my journal entries, and of course my agenda and tasks both at work and at home. 

 Hugo, on the other hand, was meant to replace WordPress. As a person who used WordPress on and off a couple of years, I expected more or less the same thing. You know, going to my webiste online somewhere, log in with a username and password, navigate the GUI and post stuff, add plugins... As such, I didn't care for a change that much. WordPress was working more or less OK, so why change to something similar and learn things all over again? 

 I get frequent alerts that my website is down from my webhost, but I got used to shrug these off. I got it as a cheap deal, and for about $6 a month or so hosting, what do you expect? People in the Emacs reddit mentioned they see more spam from my site's URL instead of my posts, but again, with 1 person complaining out of 10 or so, it wasn't a big deal. After all, SSL and https is for professional website that can afford it, and I am just an amatuer-ish blogger. Perhaps the biggest hurdle was Github: I knew people who use Hugo usually use Github to publish their blog, but they were all programmers. Me, I didn't know anything about Github or git. That was for coders, people who write scripts for a living. This is not me. I am not a porgrammer. 

 To be honest, I'm not sure what changed that perspective. Perhaps it was a random tutorial I saw about Git which made me realize it's not /that/ crazy complicated. Perhaps it was the fact that someone advised me not to link to my website again if I don't have https. Maybe it was just my inner geek, itching for a change, and WordPress was getting too familiar and too boring. Whatever it was, I took the bait, and I started doing all of it at once. 

 First I watched some Lynda videos about git and read a few posts. Then, I learned more about Hugo. After that, it was [[https://ox-hugo.scripter.co/][ox-hugo]]'s turn (because I gotta write my posts from inside Emacs), and then it was [[https://magit.vc/][Magit]] (because I gotta use git from inside Emacs). I think I went through everything in a matter of about a month. I learned too much too fast. But that's how I roll. I don't know why I do that to myself, and I'm not sure how it makes sense to go from "git is for coders" to "ALL THE THINGS," but I do anyway. 

 Obviously, this attitude has terrible consequences. You learn everything on a very shallow level, which means the first tiny bump in the road sends you launching out of control. You get frustrated and you try again, just to hit another bump. Turns out, if I /learn everything/ I also expect to /know everything/ out of myself, which is of course nonsense. But not everything is futile. Knowing the big picture in advance is not a bad idea. Learning a couple of things at once make you realize how they work together, and helps you develop a mindset that is more skilled at solving specific problems. Later, when you go look at the official documents, certain things already make sense to you even though you haven't seen them before. 

 Be it as it may, it's not easy. I wouldn't recommend this method to anyone. it's doing damage control instead of learning. However, manuals never made sese to me. In the rare occessions where I do have the patience to read through the introduction, I'd forget what I wanted to do (or how to do it) by the time I get the real stuff. Besides, manuals are usually written by the people who made the program; as such, they are written from the inside, for insiders. Certain terms and syntax make aboslutely no sense to newcomers, who find that they struggle with basic terms that the veterans spit out as if they were born into it. Indeed, if there's one thing that I kept running into when learning Emacs is /not/ to bother with its documentation. As helpful as it is, and as much as everyone loves to say all the help you ever want is C-h v (or a or whatever) away, it was not true for me. It is much, much easier to Google something up and find a blog post (or a YouTube video) that explains it to you in plain English.

Now I'm much further ahead than where I was when I started my Hugo ordeal. I have sucessfully launched a couple of testing websites on and off Github. I have whined, complained, and whined again to anyone who would listen.


So, here we are with Hugo. I use git, and well, the site is on Github. This post was written with ox-hugo. I used Magit, but because there are so many issues I'm running into, I decided to make a decision not to use it for at least another month. It's very hard to hold myself back, for sure. On one hand, since I've done WordPress for so long, I'm aching to go back to my old website where I don't have problems learning how to create a new static page (that doesn't show on the front page of this blog), or how exactly images work with these posts, or how can I automate the long process of saving a post and updating my Hugo website compared to the simple "click to publish"  in WordPress. I'm sure some of you are aching to tell me just how to do some of these things. Don't worry, I'll get back to you.  

Oh, and speaking of helpful people: a big thank you to [[https://github.com/kaushalmodi][Kaushal Modi]], who kept answering my endless questions, who was there through my frustration, anywhere I went. This guy is passionate and compassionate about what he does. 

*** PUBLISHED Org Update
  :PROPERTIES:
  :EXPORT_HUGO_SECTION: Blog
  :EXPORT_FILE_NAME: Org Update
  :EXPORT_HUGO_PUBLISHDATE: 2018-10-13:
  :END:

It’s been a while since I blogged about my Org activities. Overall, not a lot has changed from my latest setup. Setting up a new site on GitHub with Hugo kept me fairly busy, away from hacking away at Emacs.

#+hugo: more

[[file:static/OrgUpdate_1.png]]

**** Lighter Agenda: No Sub-Tasks

So, looking at my agenda sometimes less is more. I don’t rush to include every single detail in my agenda anymore, especially at work, becuase it’s redundant. We have a ticketing system that we /have/ to use, and the details are constantly updated by different team members. Because of that, updating technical details for myself again under each heading is not that appealing.

But I do still include notes. Just differently. I start notes with an inactive timestamp and describe where I left off. In other words, exactly what the subtask used to do. So I don’t bother with many sub-tasks anymore. The benefit of one heading is better visual organization. I get a nice Logbook which includes all the time I spent on the project, my notes are more streamlined and easy to find. It also clears the agenda from the clutter of subtasks that sometimes don’t make sense to me anymore because I forgot the big picture already. I also grew more comfortable with changing the header wordings of the task to better reflect what is the big picture I just mentioned. Since I keep short notes of where I left off with the most recent one at the top, it’s easy to see what’s going on.

[[file:static/OrgUpdate_2.png]]

Sometimes I would even copy-paste from the ticket straight into Org just to remind myself what was done; other times I include references to other people and cases; yet other times, if I have to vent about something, there’s a link to my journal (more on that later).

A fun sidenote: Orgzly, my companion Andoird App, [[http://www.orgzly.com/changelog][now has the ability]] to start with Org headings collapsed. This means that when I’m on the go, I can open specifically the task on hand and view my notes which I often update just before I get up to do something.

A little test here. And here.

**** Keeping Track Of Time Without Going Nuts

The Logbook contains estimated times. I almost never get to close a clock on a task once I started, because I almost never get the chance to keep working on one thing before I am called away, or have to do a prerequisite. Other times, I simply forget to start the clock. I estimate how much time I worked on something when I’m back at my desk. Now, since I don’t bother with sub-tasks and separate clocking times for these, it means I need to expend my agenda to view my logs (l in agenda view). This allows me to see the time I spent working on a certain task, even though it is marked as done later, sometimes even days (or weeks) later. This way I know when the whole task was finished, and I can see when (and for how long) I was working on it.

All of that said, most of my tasks don't get logged with a clock. That’s because many of them are simple tasks or just interruptions when I am asked a question or something similar. I should overall though get in the habit of logging tasks in retro-respect to see where my time went.

Another area I stopped worrying as much about are which org files in my archive my headers go to when I refile. This was a mouthful so let me explain.

My system is based on a weekly review. Every week has its own .org file. In the past, filenames used to specify a date range like =08102018_15102018.org=, for example. This caused me complications because I seldom had the chance to summarize and finish my week Sunday and start a clean slate Monday. Many times I wanted to conclude an .org file on a Friday after work or didn’t get the chance to do so until Monday or even Tuesday. Besides, this whole week range thing is redundant because you can always list files by dates anyway (to see when it was last modified).

On the other hand, since I started using my journal again, which is based on weeks rather than months, it made more sense to name the files after the number of the weeks. For instance, this week is w41.org, last week was w40.org, etc. My journal tells me what week I’m on if I ever need to reflect, the file name is very clear and obvious and there’s no room for confusion. My weekly summaries will always be based on their respective =<number>.org=, even if I summarize a month later.

In the past, I refiled events and tasks depending on what week they were to take place. If I was planning a vacation four weeks in advance, for example, I would open a new file for that week and place the event there. This lead to all kinds of problems when I worked on projects that stretched over more than just a weekly period. Let’s say I take a vacation from Friday to Monday of next week. Now what, which file do I choose? At the time, I opted for the completion date. But, this too wasn’t simple. Because certain projects (especially at work) could last even months, or re-surface from the past. That would mean I would have to move them to the appropriate week and think about what “done” really means. One day thinking about it out loud, I just started laughing at myself: “dude,” I said, as I like to refer anyone for some reason, “what are you doing? Org takes care of all of that for you automatically! That’s what’s the Agenda is for!” Who cares if I placed a project in week 20 or week 30, I don’t ever search it that way or know where it comes from anyway, I just see it on the agenda or search for it with the agenda anyway =(C-a s)=. That’s what it’s for. So I stopped caring about that, and events now naturally fall into the week I created them.

**** The Journal Revisited

I don’t use the journal as much as I used to when I had it earlier this year. I find that I use it capture experiences and emotions more than technical notes. For the later, I now have an org file called “wiki” which I keep organized as it grows further. The journal is good to keep moods and mental “patterns” I can look into on my weekly review. For this, I also use tags. This is a good exercise that allows me to recognize mental “traps” I get into more often than not.

The journal works nicely with my weekly reviews, which are essentially weekly videos I make reading back from my agenda and journal. With time, these became more of a personal “summary of summaries” where I highlight my week tasks and review, usually for a 10-minute segment or so. I keep these in a well-compressed mp4 format on an SD card ([[https://ffmpeg.org/][FFMPEG]] is awesome for that) and I can easily use one SSD for an entire year and still have additional room. I am now starting to name the videos based on the same weekly theme that I use for my weekly agenda files and journal.

*** ACTIVE Emacs Windows Managment
  :PROPERTIES:
  :EXPORT_HUGO_SECTION: Blog
  :EXPORT_FILE_NAME: Emacs Windows Managment
  :END:

In his 5th Emacs podcast, [[https://emacscast.org/episode_5/][Rakhim]] discusses the difficulties of windows management in Emacs. I agree with him. Emacs' Windows are a pain. It was probably one of the longest pet peeves I had with the program, and it wasn't until this podcast that I realized that I'm much better off than I used to be. 

#+hugo: more

I don't use any extension that manages windows (unless you consider Ivy's switch buffer, which he uses too. [[https://oremacs.com/swiper/][Ivy]] is awesome). My method is based on bits and pieces I picked up. Here are a couple of lines from my settings.org, which I use to make Emacs' windows work better for me. 

First, for my ultra-wide screen at home, it helps to enlarge the default frame size. After a few tests, I found this size satisfying: 
#+BEGIN_SRC emacs-lisp 
(setq default-frame-alist '((width . 90) (height . 50) (menu-bar-lines . 6)))
#+END_SRC

Then, we need to turn on the mouse vertical mouse divider. This will allow us to use the mouse to drag and adjust windows in our frame vertically as well. I actually don't use this as much anymore (the reason is coming up) but this is a basic feature that should be on by default, in my opinion: 
#+BEGIN_SRC emacs-lisp
(window-divider-mode +1)
#+END_SRC

Another basic feature, which I now use everywhere, is the [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Visual-Line-Mode.html][visual line mode]]. If you write more than you code on Emacs (which is true in my case) this mode just makes sense. 
#+BEGIN_SRC emacs-lisp
(global-visual-line-mode +1)
#+END_SRC

Those are all good and nice, but here's the biggest tip which I stumbled upon a few months back, from [[http://ergoemacs.org/emacs/emacs_effective_windows_management.html][Ergoemacs]]: just don't use windows. Use frames. Seriously, it's that simple. There are probably many Emacs experts out there with their windows functions and extensions and what not, but let's not reinvent the wheel here. If there's one thing a GUI is good for is to manage windows (or frames in Emacs). They are very easy to move with the mouse, they snap to each other, easy to resize. Besides, Emacs itself splits the frames to Windows often enough. I find that I use C-0 and C-1 very often to get rid of windows I don't need, and I can have them back quickly by switching back to the buffer with Ivy.

One of the things that used to drive my bananas when I started using Org was how the agenda and its habit to kill my windows setup. One of the most helpful lines in my settings.org is the following: 

#+BEGIN_SRC emacs-lisp
(setq org-agenda-window-setup (quote other-frame))
#+END_SRC

This saved me from going insane. Since I start up my agenda every time I start up my Emacs, this shortcut also effectively creates the other frame for me to work with until I exit Emacs. From there, I can just use the Agenda frame itself to switch to another buffer if I want to. Agenda is also the only place where I do use windows often - when I tab into one of my headers there. I tab into a task, view it, make changes if I want, save, and C-0 to return to full agenda view. It's so fast it's just my muscle memory now. 
